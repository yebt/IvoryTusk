#!/bin/env bash

# --------------------------------------------------------
# This file is an abstraction of the interface for the
# commands files
# --------------------------------------------------------

declare COMMAND_HELP_TEXT=${COMMAND_HELP_TEXT:-}
declare -a ARGUMENTS=${ARGUMENTS:-()}
declare -a FLAGS=${FLAGS:-()}

# --------------------------------------------------------
declare -a CONFIFURED_ARGS=()
# declare -a CONFIFURED_FLAGS=()
# --------------------------------------------------------

# has_required() {
#     debug "Checking if the command has required params"
# }

checl_required() {
    local required_args=()
    local required_flags=()

    for arg in "${ARGUMENTS[@]}"; do
        if echo "$arg" | grep -q ";required" && ! echo "$arg" | grep -q ";required:false"; then
            name="$(echo "$arg" | grep -Po "(?<=name:)[^;]+")"
            required_args+=("$name")
        fi
    done

    for flag in "${FLAGS[@]}"; do
        if echo "$flag" | grep -q ";required" && ! echo "$flag" | grep -q ";required:false"; then
            name="$(echo "$arg" | grep -Po "(?<=name:)[^;]+")"
            required_flags+=("$name")
        fi
    done

    if [ ${#required_args[@]} -gt 0 ] || [ ${#required_flags[@]} -gt 0 ]; then
        error "The command has required params"
        if [ ${#required_args[@]} -gt 0 ]; then
            show_param_title "Required arguments:"
            for arg in "${required_args[@]}"; do
                echo "${TAB}${TAB}$arg"
            done
        fi
        if [ ${#required_flags[@]} -gt 0 ]; then
            show_param_title "RCONFIFURED_ARGSequired flags:"
            for flag in "${required_flags[@]}"; do
                echo "${TAB}${TAB}--$flag"
            done
        fi
        exit 1
    fi
}

# --------------------------------------------------------

zero_params_call() {
    checl_required
}

command_help() {
    if [ -n "$COMMAND_HELP_TEXT" ]; then
        show "$COMMAND_HELP_TEXT"
    else
        warning "Command help not found" "Please, set the 'COMMAND_HELP_TEXT' variable"
    fi
}

command_complete_help() {

    # config args
    show_param_title "Arguments:"
    for arg in "${ARGUMENTS[@]}"; do
        argument_name="$(echo "$arg" | grep -Po "(?<=name:)[^;]+")"
        argument_help="$(echo "$arg" | grep -Po "(?<=help:)[^;]+")"
        show_aligned_help_message "$argument_name" "20" "$argument_help" "."
    done

    # config flags
    show_param_title "Flags:"
    for flag in "${FLAGS[@]}"; do
        flag_name="$(echo "$flag" | grep -Po "(?<=long:)[^;]+")"
        flag_help="$(echo "$flag" | grep -Po "(?<=help:)[^;]+")"
        show_aligned_help_message "$flag_name" "20" "$flag_help" "."
    done
}

# this functin load the enought vars to the flags and args exists
config_args_and_flags() {

    # config args
    for arg in "${ARGUMENTS[@]}"; do
        IFS=';' read -r -a arg_parts <<<"$arg"
        argument_name=""
        for config in "${arg_parts[@]}"; do
            # declare the var
            IFS=':' read -r -a config_parts <<<"$config"
            local config_name="${config_parts[0]}"
            local config_value="${config_parts[1]}"
            if [ "$config_name" == "name" ]; then
                argument_name="$config_value"
            fi
            if [ -z "$argument_name" ]; then
                error "Argument name not found"
                exit 1
            fi
            declare "arg_${argument_name}_${config_name}"="${config_value}"
        done
        CONFIFURED_ARGS+=("$argument_name")
    done

    # config flags
    for flag in "${FLAGS[@]}"; do
        IFS=';' read -r -a flag_parts <<<"$flag"
        flag_name=""
        for config in "${flag_parts[@]}"; do
            # declare the var
            IFS=':' read -r -a config_parts <<<"$config"
            local config_name="${config_parts[0]}"
            local config_value="${config_parts[1]}"
            if [ "$config_name" == "long" ]; then
                flag_name="$config_value"
            fi
            if [ -z "$flag_name" ]; then
                error "Flag 'name' not found, check the order of attributes"
                exit 1
            fi
            if [ "$config_name" == "short" ]; then
                export "flag_${config_value}_short_to_long"="$flag_name"
            fi
            export "flag_${flag_name}_${config_name}"="${config_value}"
        done
    done

}

load_params() {

    # check if --help or -h exist in the params
    has_help="$(echo "$@" | grep -Po "(?<=--help|-h)[^ ]+")"

    if [ -n "$has_help" ]; then
        command_complete_help
        exit 0
    fi

    # load the params
    while [ "$#" -gt 0 ]; do
        param="$1"
        next_param="$2"

        ## check if is a flag
        if [[ "$param" == -* ]]; then
            # is a flag
            ## extract the value if there is one with=
            local flag_input_value=""
            if [[ "$param" =~ = ]]; then
                IFS='=' read -r -a flag_parts <<<"$param"
                param="${flag_parts[0]}"
                flag_input_value="${flag_parts[1]}"
            fi
            ## check if is a short flag
            if [[ "$param" != --* ]]; then
                ## convert to long flag
                local short_flag_name="${param:1}"
                local long_flag_name_var="flag_${short_flag_name}_short_to_long"
                local lon_flag_name="${!long_flag_name_var}"
                if [ -z "$lon_flag_name" ]; then
                    error "Flag '$short_flag_name' not found" "Use '--help' for more info"
                fi
                param="--$lon_flag_name"
            fi

            ## Process the flag attributes
            local flag_name="${param:2}"
            local flag_var_name="flag_${flag_name}"

            export "$flag_var_name"=true
            ## if exist argument property for the flag try get value
            local flag_arg_var_name="flag_${flag_name}_arg"
            local flag_arg_var_value="${!flag_arg_var_name}"
            if [ -n "${flag_arg_var_value}" ]; then
                local flag_required_var_name="flag_${flag_name}_required"
                local flag_default_var_name="flag_${flag_name}_default"
                # argument exists
                ## check if the value is getted by = or is the next param
                if [ -z "$flag_input_value" ]; then
                    if [[ -n "$next_param" ]] && [[ "$next_param" != -* ]]; then
                        flag_input_value="$next_param"
                        shift
                    elif [[ -n "${!flag_required_var_name}" ]] && [[ -z "${!flag_default_var_name}" ]]; then
                        error "Flag '$flag_name' required a value" "Please provide a value for the flag"
                        exit 1
                    elif [[ -n "${!flag_default_var_name}" ]]; then
                        flag_input_value="${!flag_default_var_name}"
                    fi
                fi

                ## if exst choises, validate the value in the choises
                local flag_choices_var_name="flag_${flag_name}_choices"
                if [ -n "${!flag_choices_var_name}" ]; then
                    local flag_choices_var_value="${!flag_choices_var_name}"
                    # remove []
                    flag_choices_var_value="${flag_choices_var_value:1:-1}"
                    local choises_array=(${flag_choices_var_value//,/ })
                    if [[ ! "${choises_array[*]}" =~ $flag_input_value ]]; then
                        alloed_choices="${choises_array[*]}"
                        error "Flag '$flag_name' value '$flag_input_value' not valid" "Allowed values: $alloed_choices"
                        exit 1
                    fi
                fi
                ## if is repeatable, the value could be an array and check if appennd or create
                local flag_repeatable_var_name="flag_${flag_name}_repeatable"
                local flag_repeatable_var_value="${!flag_repeatable_var_name}"
                local flag_arg_to_save_name="flag_${flag_name}_arg_${flag_arg_var_value}"
                if [ -n "$flag_repeatable_var_value" ]; then
                    if [ -z "${!flag_arg_to_save_name}" ]; then
                        eval "$flag_arg_to_save_name=()"
                        export "${flag_arg_to_save_name?}" # export
                    fi
                    eval "$flag_arg_to_save_name+=(\"$flag_input_value\")"
                    # eval "echo \${${flag_arg_to_save_name}[@]}"
                    export "${flag_arg_to_save_name?}" # export
                else
                    export "$flag_arg_to_save_name"="$flag_input_value" # export
                fi
            fi

        fi
        shift
    done

    # for prop in "$@"; do
    #     # check if is a flag
    #     if [[ "$prop" == -* ]]; then
    #         echo "flag: $prop"
    #         local flag_input_value=""
    #         # separathe if has and =
    #         if [[ "$prop" =~ = ]]; then
    #             IFS='=' read -r -a flag_parts <<<"$prop"
    #             prop="${flag_parts[0]}"
    #             flag_input_value="${flag_parts[1]}"
    #         fi
    #         if [[ "$prop" != --* ]]; then
    #             # convert to long flag
    #             local short_flag_name="${prop:1}"
    #             local long_flag_name_var="flag_${short_flag_name}_short_to_long"
    #             local lon_flag_name="${!long_flag_name_var}"
    #             if [ -z "$lon_flag_name" ]; then
    #                 error "Flag '$short_flag_name' not found" "Use '--help' for more info"
    #             fi
    #             prop="--$lon_flag_name"
    #         fi

    #         # prop is a flag
    #         # set the flag value in true
    #         local flag_name="${prop:2}"
    #         local flag_var_name="flag_${flag_name}"
    #         export "$flag_var_name"=true
    #         # if has an argument try save the value in the flag attrib name
    #         local flag_arg_var_name="flag_${flag_name}_arg"
    #         if [ -n "${!flag_arg_var_name}" ]; then
    #             # argument exists
    #             # check if the value is getted by = or is the next param
    #             if [ -n "$flag_input_value" ]; then
    #                 debug "$flag_input_value"
    #             else
    #                 next_param="${1}"
    #                 debug "$next_param"
    #             fi
    #             # export "flag_${flag_name}_arg_${!flag_arg_var_name}"="$flag_input_value" # expor
    #             # debug "$flag_arg_var_name ${!flag_arg_var_name}"
    #         fi

    #     fi

    #     # if [[ "$prop" =~ -- ]]; then
    # done

    # check if required flags exists
    # check if required args exists

}
# --------------------------------------------------------

if [ "$#" -eq 0 ]; then
    zero_params_call
fi

# Show minimal help
if [ "$1" == "--command-help" ]; then
    command_help
    exit 0
fi

# config_args_and_flags
if [ "$1" == "--help" ] || [ "$1" == "-h" ]; then
    shift
    command_complete_help
    exit 0
fi

# catch the coomand
config_args_and_flags
load_params "$@"
