#!/bin/env bash

# --------------------------------------------------------
# This file resolve all modules aviables and the commands
# inside them
# --------------------------------------------------------

# --------------------------------------------------------
declare -a MODULES=() # modules of commands
declare LONGUEST_COMMAND_NAME=0
declare COMMANDS_DIR="$WORKDIR/commands"
declare HELP_SEPARATOR_LENGTH=10
# --------------------------------------------------------

# Resolves all modules and their commands.
#
# This function searches for all modules and their commands inside them. It iterates over each file
# found in the "$WORKDIR/commands" directory and extracts the filename, relative path to the module,
# container directory name, and command name. If the container directory name is not empty, it appends
# it to the command name separated by a colon. The command name and relative path to the module are then
# added to the MODULES array.
#
# Parameters:
#   None
#
# Returns:
#   None
resolve_all_modules() {
    root_dir="$COMMANDS_DIR"
    # check if the commands directory exists
    if [ ! -d "$root_dir" ]; then
        error "Commands directory not found"
        exit 1
    fi
    while IFS= read -r file; do
        local filename
        local relative_path_to_module
        local container_dirname
        local COMMAND_NAME

        filename=$(basename "$file" .sh)
        relative_path_to_module="${file#"$root_dir"/}"
        container_dirname="$(dirname "$relative_path_to_module")"
        COMMAND_NAME="$filename"
        if [ "$container_dirname" != "." ]; then
            COMMAND_NAME="$container_dirname:$filename"
        fi

        MODULES+=("$COMMAND_NAME;$relative_path_to_module")
        if [ "${#COMMAND_NAME}" -gt "$LONGUEST_COMMAND_NAME" ]; then
            LONGUEST_COMMAND_NAME="${#COMMAND_NAME}"
        fi
    done < <(find "$root_dir" -maxdepth 2 -type f -name "*.sh")
}
# --------------------------------------------------------

resolve_all_modules

show_commands_help() {
    nl
    if [ "${#MODULES[@]}" -eq 0 ]; then
        error "No commands found" "Need create a command in the 'commands' directory"
        exit 1
    fi

 
    actual_module_name=""
                show_param_title "Available commands:"

    for module in "${MODULES[@]}"; do
        IFS=";" read -r -a module_parts <<<"$module"
        COMMAND_NAME="${module_parts[0]}"

        IFS=":" read -r -a command_parts <<<"$COMMAND_NAME"
        COMMAND_MODULE=""
        if [ "${#command_parts[@]}" -gt 1 ]; then
            COMMAND_MODULE="${command_parts[0]}"
        fi
        COMMAND_PATH="${module_parts[1]}"

        if [ "$COMMAND_MODULE" != "$actual_module_name" ]; then
            actual_module_name="$COMMAND_MODULE"
            if [ -n "$actual_module_name" ]; then
                show_param_title " $actual_module_name"
            else
                show_param_title " ~"
            fi
        fi

        COMMAND_HELP_TEXT="$(sh "$WORKDIR/modules/command_handler" "$COMMAND_PATH" --command-help)"
        show_aligned_help_message "$COMMAND_NAME " "$((LONGUEST_COMMAND_NAME + HELP_SEPARATOR_LENGTH))" "$COMMAND_HELP_TEXT" "."
    done
}
