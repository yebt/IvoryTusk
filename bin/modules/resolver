#!/usr/bin/env bash

# Loads a list of modules into the specified array.
#
# This function takes a reference to an array as a parameter and populates it with the names of the modules found in the COMMANDS_DIR directory. Each module name is constructed by removing the COMMANDS_DIR prefix and the .sh extension from the file name. If the file name contains a directory path, the directory name is included in the module name.
#
# Parameters:
# - $1: The name of the array to populate with the module names.
#
# Returns:
# None.
load_list_of_modules() {
    local -n arr=$1

    while IFS= read -r -d '' file; do
        baseResuult=""
        file="${file##"$COMMANDS_DIR/"}"
        file="${file%.sh}"
        if [[ $file == */* ]]; then
            baseResuult+="$(dirname "$file"):"
            baseResuult+=$(basename "$file")
        else
            baseResuult+="$file"
        fi
        arr+=("$baseResuult")
    done < <(find "$COMMANDS_DIR" -type f -name "*.sh"  -not -path '*/.*' -print0)
}

resolve_module() {
    command_name=$1
    IFS=":" read -ra command_array <<<"$command_name"
    module=${command_array[0]}
    command=${command_array[1]}

    caller="$COMMANDS_DIR/$module"
    if [ -n "$command" ]; then
        caller="$caller/$command"
    fi
    caller="$caller.sh"
    echo "$caller"
}

call_command_help() {
    command=$1
    longest=$2
    default_module_name=$3
    local -n actual_module_ref=$4
    # split module by :
    IFS=: read -ra module_array <<<"$command"
    first_commannd_part="${module_array[0]}"
    second_command_part="${module_array[1]}"
    if [ -z "$second_command_part" ]; then
        second_command_part="$first_commannd_part"
        first_commannd_part="$default_module_name"
    fi
    if [ "$actual_module_ref" != "$first_commannd_part" ]; then
        actual_module_ref="$first_commannd_part"
        echo -e "${TAB}${BOLD}${YELLOW}${actual_module_ref}${RESET}"
    fi
    command_file="$(resolve_module "$command")"
    command_help_text="$(sh "$command_file" -h)"
    command_text="$(printf "%-${longest}s" "$command")"
    echo -e "${TAB}${TAB} ${GREEN}${command_text}${RESET}${TAB} $command_help_text${RESET}"
}


call_command_run() {
    command=$1
    shift
    # args=("$@")
    # echo "Running $command with args: ${args[*]}"
    command_file="$(resolve_module "$command")"
    if [ ! -f "$command_file" ]; then
        echo -e "${RED}Command not found:${RESET}${BOLD} $command${RESET}"
        echo -e "Try ${BOLD}ivorytcli [--help|-h]${RESET} for a list of available commands"
        exit 1
    fi
    # sh "$command_file" -r "$@" 
}